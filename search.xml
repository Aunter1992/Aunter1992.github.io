<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>平台对接</title>
      <link href="/BVRP3.0_Plugins/%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%8E%A5/"/>
      <url>/BVRP3.0_Plugins/%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>平台对接的文件夹名为OwvlabInteraction，基于BVRP3.0基础框架内容实现，包含了pc、webgl、云平台三种平台获取实验当前登录的用户信息的方式，<br>并提供了统一的实验内容上传接口，由PlatformInteraction来处理完成，具体的流程如下图示：</p><img src="/BVRP3.0_Plugins/%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%8E%A5/1-1.jpg" class=""><a id="more"></a><hr><h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><ul><li>旧平台：根据中文提示 填充对应的URL,如果是采用PC版本，则需要自定义esid,需注意URL之间的斜杠符号.</li></ul><p><img src="2-1.jpg" alt="旧平台"></p><ul><li>新平台：按照中文提示填写对应的URL，实验唯一标识码可在平台的实验资源中查看，新平台的成绩和报告URL后缀是通过登录来获取，默认是不变的，所以直接在配置中给出。</li></ul><p><img src="2-2.jpg" alt="新平台"></p><hr><h1 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h1><h2 id="脚本挂载"><a href="#脚本挂载" class="headerlink" title="脚本挂载"></a>脚本挂载</h2><p>挂载PlatformInteraction脚本或者是继承自PlatformInteraction的子类，选择相应的平台，如果是pc版，则填写相应的用户名和密码。具体如下图所示，使用时挂载一个即可，在程序运行开始，会自动登录获取相应的用户信息</p><p><img src="3-1.jpg" alt=""></p><h2 id="成绩上传"><a href="#成绩上传" class="headerlink" title="成绩上传"></a>成绩上传</h2><p>   成绩上传包含三个平台。根据网络平台的不同，具体的操作方式也有不相同的地方。</p><h3 id="旧平台"><a href="#旧平台" class="headerlink" title="旧平台"></a>旧平台</h3><ul><li><p>说明</p><p> 旧平台，不论是webgl、pc、还是云平台，在获取到用户登录信息之后，都是通过Http请求的方式，上传数据</p></li><li><p>调用</p><p>上传成绩可直接调用PlatformInteraction类中的成员函数UploadScore,参数为实验成绩，一般为int型</p><p><img src="3-2.jpg" alt=""></p></li></ul><h3 id="新平台"><a href="#新平台" class="headerlink" title="新平台"></a>新平台</h3><ul><li>说明</li></ul><p>新平台，也称简易平台。如果发布的平台是WebGL版本，需要根据网络平台给出的参考文档和文件，修改发布后的index文件，以及放置提供的文件到对应的位置。具体操作流程，参考对应的网络平台提供的操作文档</p><p>如果是pc（暂未使用过）和云平台，则依旧按照Http的方式。</p><ul><li>调用</li></ul><p>WebGL：直接调用PlatformInteraction类中的成员函数SendScoreToWeb,参数为实验成绩，一般为int型</p><p><img src="3-3.jpg" alt=""></p><p>Pc和云平台：直接调用前面提到的UploadScore方法。</p><h2 id="实验报告上传"><a href="#实验报告上传" class="headerlink" title="实验报告上传"></a>实验报告上传</h2><ul><li>说明</li></ul><p>由于实验报告上传内容各不相同，所以需要自行编写上传的实验数据。数据编写完成后，直接利用PlatformInteraction类中提供的ExcuteRequest方法提交数据即可</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>接口引用</li></ul><p>建议直接继承PlatformInteraction类，并重新实现对应的实验报告上传，等内容。然后作为全局单例引用</p><ul><li>用户信息</li></ul><p>当程序初始化完成，成功获取用户信息后，会作为静态变量userInfo存储在PlatformLoginProxy中，可直接使用。</p><ul><li>定义回调函数</li></ul><p>在PlatformInteraction类提供了空的回调方法 LoginCallBack，具体的内容，程序员可根据情况不同，自定义。</p>]]></content>
      
      
      <categories>
          
          <category> BVRP3.0_Plugins </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存储系统</title>
      <link href="/BVRP3.0_Plugins/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/BVRP3.0_Plugins/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>   StorageSystem插件，是基于BVRP3.0基础框架而开发的，实现了对属性变化以及方法调用 产生的事件消息体的记录、序列化、反序列化。通过对已记录事件的广播，从而达到实验的回放功能。具体的流程如下图所示。</p><img src="/BVRP3.0_Plugins/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1-1.jpg" class="" title="基本流程"><hr><a id="more"></a><h1 id="文件结构及内容"><a href="#文件结构及内容" class="headerlink" title="文件结构及内容"></a>文件结构及内容</h1><p><img src="2-1.jpg" alt=""></p><ul><li><p><strong>Handler文件夹</strong></p><p>包含3个业务逻辑处理类：</p><p>LocalDataHandler：将序列化后的事件消息体保存到本地（Pc、WebGL）</p><p>NetDataHandler：将序列化后的事件消息体保存到网络服务器上（需要定义URL和对应的请求参数）</p><p>VideoHandler：录像回放的播放器，将反序列化后的事件消息体，按照帧顺序逐一广播。</p></li><li><p><strong>Hepler文件夹</strong></p><p>主要包含录像功能的几个辅助性功能类：</p><p>ScreenMask：用于上传，存储数据等待过程中的UI遮罩</p><p>UIAnchorUtility：通过代码设置UGUI的Anchor锚点</p><p>ZipUtility：提供常用的压缩、解压缩API</p></li></ul><ul><li><p><strong>UIView文件夹</strong></p><p>包含录像回放用到UI功能类:</p><p>UIEventSupportView:作为基类使用，主要用于UI的事件源基类</p><p>UIStorageView：提供实验中产生的数据保存以及加载的UI界面  </p><p><img src="2-2.png" alt=""></p><p>UIReplayView：录像回放中的UI界面</p><p><img src="2-3.png" alt=""></p></li></ul><ul><li><p><strong>WebGLWebAPI文件夹</strong></p><p>包含一个接口以及jslib接口的包装类：</p><p>IWebGlWebAPIService：定义jslib接口中实现的方法</p><p>WebGLWebAPIServiceWapper：实现对jslib中的方法调用。主要包含在WebGL上打印日志，存储文本到本地以及从本地读取文本</p></li><li><p><strong>EventPool</strong></p><p> 事件消息体对象池，用于存储在整个软件生命周期中，所产生的每个事件消息体，默认情况包括属性事件和方法事件</p></li><li><p><strong>EventStorageLogic</strong></p><p>存储事件消息的业务逻辑，包含对事件消息体的存储，以及对事件消息体的过滤</p></li><li><p><strong>StorageConfigSettings</strong></p><p>存储系统的配置脚本，用于初始化存储系统，可设置是否使用存储系统，或者使用扩展的存储系统</p></li><li><p><strong>StorageIgnored</strong></p><p>特性标签，用于过滤事件消息体 </p></li><li><p><strong>StorageSystem</strong></p><p>默认的存储系统管理类，提供事件消息体的序列化还反序列化、数据的保存和加载以及录像回放的初始化，可继承重写部分逻 </p></li></ul><hr><h1 id="存储系统应用"><a href="#存储系统应用" class="headerlink" title="存储系统应用"></a>存储系统应用</h1><p>整个存储系统应用比较简单，给定几个简单的设置，挂载对应的事件消息体记录脚本，即可。前提是整个软件的编程环境是基于BVRP3.0的事件系统来完成的。</p><h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><ul><li>修改存储系统配置脚本(StorageConfigSetting),如下图</li></ul><p><img src="3-1.png" alt="配置脚本">            </p><ul><li>数据存储配置</li></ul><p><img src="3-2.png" alt="宏定义配置"></p><h2 id="事件记录"><a href="#事件记录" class="headerlink" title="事件记录"></a>事件记录</h2><p>事件记录默认只需要将EventStorageLogic脚本挂载到带有DataModelBehaviour的GameObject上即可。如果要实现回放，每个带有DataModelBehaviour的GameObject也必须挂载UniqueID脚本。</p><h3 id="实体是继承自Entity的事件记录"><a href="#实体是继承自Entity的事件记录" class="headerlink" title="实体是继承自Entity的事件记录"></a>实体是继承自Entity的事件记录</h3><p>EventStorageLogic也是继承自LogicBehaviour的，凡是有实体数据变化或方法调用的事件，都会有由DataModelBeahviour接收到，并路由到所有已挂载的LogicBehaviour上</p><p><img src="3-3.jpg" alt=""></p><h3 id="实体是继承自EventSupportBehaviour的事件记录"><a href="#实体是继承自EventSupportBehaviour的事件记录" class="headerlink" title="实体是继承自EventSupportBehaviour的事件记录"></a>实体是继承自EventSupportBehaviour的事件记录</h3><p>这种情况下 实体即EventSupprotBehaviour，也会由DataModelBehaviour来接收由EventSupprotBehaviour发出的属性变化和方法调用事件，路由到LogicBehaviour。</p><p><strong>特别说明：</strong>在这种情况下，如果业务逻辑都是在EventSupportBehaviour中处理的，则就不需要挂载LogicBehaviour，只挂载EventStorageLogic记录事件即可</p><p><img src="3-4.jpg" alt=""></p><hr><h1 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h1><p><strong>必要条件</strong>：如果要使用自定义的数据存储以及UI，首先需要继承StorageSystem，参考父类重写相关的虚函数。在StorageConfigSettings配置脚本中，实例化对应的子类。</p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><ul><li>数据存储</li></ul><p>参考对应的NetDataHandler或者LocalDataHandler，编写对应的数据持久化内容。在继承自StorageSystem的子类中实例化，并使用。</p><ul><li>UI</li></ul><p>继承UIEventSupprotView，编写对应的保存、加载UI（在配置脚本中实例化），以及播放器UI。在继承自StorageSystem的子类中实例化。</p><ul><li>播放器</li></ul><p>参考ViedoHandler，处理EventPool中的事件消息队列。在继承自StorageSystem的子类中实例化。</p><hr><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在实现录像回放时，可以采用比较简单的方式，比如记录所有的方法调用事件，需要注意参数的类型是否支持序列化。<br>对于动态生成物体，需要在编辑器状态下勾选上UniqueID的IsPrefab选项</p>]]></content>
      
      
      <categories>
          
          <category> BVRP3.0_Plugins </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unty发布Logo设置</title>
      <link href="/Unity_BulidSettings/Unity%E5%8F%91%E5%B8%83Logo%E8%AE%BE%E7%BD%AE/"/>
      <url>/Unity_BulidSettings/Unity%E5%8F%91%E5%B8%83Logo%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>文章中提到的pcIamge、WebGLTemplates、WebplayerImage资源文件夹请前往公司git资源库下载</strong></p><p><a href="http://git.owmlab.net/tree/GongXiangZiYuan%2FGongGongDaiMa.git" target="_blank" rel="noopener">链接地址</a> 下载Unity打包Logo.rar</p><h1 id="WebGL设置Logo"><a href="#WebGL设置Logo" class="headerlink" title="WebGL设置Logo"></a>WebGL设置Logo</h1><h2 id="拷贝WebGLTemplates到Assets目录下"><a href="#拷贝WebGLTemplates到Assets目录下" class="headerlink" title="拷贝WebGLTemplates到Assets目录下"></a>拷贝WebGLTemplates到Assets目录下</h2><img src="/Unity_BulidSettings/Unity%E5%8F%91%E5%B8%83Logo%E8%AE%BE%E7%BD%AE/1-1.png" class=""><a id="more"></a><h2 id="设置实验名称"><a href="#设置实验名称" class="headerlink" title="设置实验名称"></a>设置实验名称</h2><p>选择File-&gt;Build Setting-&gt;PlayerSettings,在Product Name中填入实验名称</p><p><img src="1-2.png" alt=""></p><h2 id="设置统一实验分辨率"><a href="#设置统一实验分辨率" class="headerlink" title="设置统一实验分辨率"></a>设置统一实验分辨率</h2><ul><li><p>选择Resolution and Presentation</p></li><li><p>填写分辨率为960*540</p></li><li><p>选择RainierTemplate</p></li></ul><p><img src="1-3.png" alt=""></p><h2 id="设置加载背景图"><a href="#设置加载背景图" class="headerlink" title="设置加载背景图"></a>设置加载背景图</h2><p>进入Assets\WebGLTemplates\RainierTemplate\TemplateData文件夹，替换下列文件为目标文件即可</p><ul><li>bg-Image.jpg：为目标背景图</li><li>progressEmpty.Dark.png：加载进度条边框</li><li>progressFull.Dark.png：加载进度条</li><li>progressLogo.Dark.png：加载logo</li></ul><p>默认效果图：</p><p><img src="1-4.jpg" alt=""></p><h2 id="去掉show-Splash-Screen选项"><a href="#去掉show-Splash-Screen选项" class="headerlink" title="去掉show Splash Screen选项"></a>去掉show Splash Screen选项</h2><p><img src="1-5.png" alt=""></p><hr><h1 id="Windows设置Logo"><a href="#Windows设置Logo" class="headerlink" title="Windows设置Logo"></a>Windows设置Logo</h1><p>选择File-&gt;Build Setting-&gt;PlayerSettings</p><h2 id="设置实验名称和ICON"><a href="#设置实验名称和ICON" class="headerlink" title="设置实验名称和ICON"></a>设置实验名称和ICON</h2><p><img src="2-1.jpg" alt=""></p><h2 id="设置分辨率为1920-1080"><a href="#设置分辨率为1920-1080" class="headerlink" title="设置分辨率为1920*1080"></a>设置分辨率为1920*1080</h2><p>填写实验名称，选择PcImage文件夹下的Icon.png</p><p><img src="2-2.jpg" alt=""></p><h2 id="Logo图片导入设置"><a href="#Logo图片导入设置" class="headerlink" title="Logo图片导入设置"></a>Logo图片导入设置</h2><p>设置Mesh Type为Full Rect</p><p><img src="2-3.png" alt=""></p><h2 id="选择Splash-Image"><a href="#选择Splash-Image" class="headerlink" title="选择Splash Image"></a>选择Splash Image</h2><ul><li>勾选show Splash Screen</li><li>设置logos列表图片:PcImage文件夹下的logo.png</li><li>设置Background Image:PcImage文件夹下的bg-Image</li></ul><p><img src="2-4.jpg" alt=""></p><h2 id="设置完成效果图预览"><a href="#设置完成效果图预览" class="headerlink" title="设置完成效果图预览"></a>设置完成效果图预览</h2><p><img src="2-5.jpg" alt=""></p><hr><h1 id="WebPlayer设置Logo"><a href="#WebPlayer设置Logo" class="headerlink" title="WebPlayer设置Logo"></a>WebPlayer设置Logo</h1><h2 id="设置实验名称和分辨率"><a href="#设置实验名称和分辨率" class="headerlink" title="设置实验名称和分辨率"></a>设置实验名称和分辨率</h2><p><img src="3-1.jpg" alt=""></p><p>设置完成后直接打包生成可执行文件</p><h2 id="修改打包完成后的index-html文件"><a href="#修改打包完成后的index-html文件" class="headerlink" title="修改打包完成后的index.html文件"></a>修改打包完成后的index.html文件</h2><ul><li>删除Unity Web Player 文字，只保留实验名称</li></ul><p><img src="3-2.jpg" alt=""></p><ul><li>删除<span>标签以及Unity WebPlayer文字，只保留实验名称</li></ul><p><img src="3-3.jpg" alt=""></p><ul><li>删除底部p标签这一行，即Create with unity字样</li></ul><p><img src="3-4.png" alt=""></p><ul><li>找到如下图示的代码部分，删除这部分代码，在删除的代码部分，添加如下代码</li></ul><p><img src="3-5.jpg" alt=""></p><pre><code>var params = {            width: 960,             height: 540,            backgroundcolor: &quot;000000&quot;,            bordercolor: &quot;000000&quot;,            textcolor: &quot;FFFFFF&quot;,            logoimage: &quot;logo.png&quot;,            progressbarimage: &quot;progressFull.png&quot;,            progressframeimage: &quot;progressEmpty.png&quot;               };      params[&quot;disableContextMenu&quot;] = true;var u = new UnityObject2({ params: params });</code></pre><p>替换后</p><p><img src="3-6.jpg" alt=""></p><h2 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h2><ul><li>将打包logo设置文件夹中的WebplayerImage文件夹下的logo、progressEmpty、progerssFull三张图片拷贝到打包文件夹下</li></ul><p><img src="3-7.jpg" alt=""></p><ul><li>示意图</li></ul><p><img src="3-8.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Unity发布 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Watch结构</title>
      <link href="/BVRP3.0_Turtorials/Watch%E7%BB%93%E6%9E%84/"/>
      <url>/BVRP3.0_Turtorials/Watch%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Watch概要"><a href="#Watch概要" class="headerlink" title="Watch概要"></a>Watch概要</h1><ul><li>介绍</li></ul><p>Watch结构作为 BVRP的核心，是基于<strong>事件系统</strong>并借鉴 MVVM设计而成的一个<strong>三层结构体系</strong>，由数据实体、数据载体、业务逻辑组成，适用于解耦合三维模型和数据模型，具备良好的对象间通信机制，主要用于GameObject的数据层控制。</p><ul><li>说明</li></ul><p>沿用2.0的三层结构，保持编码格式，形成统一的编程规范</p><p>分离数据与业务逻辑，实现更智能的智能指导和批改</p><p>以事件驱动，更简易的实现对实现的录像回放</p><ul><li>相对于2.0优点</li></ul><p>Entity实现<strong>组合</strong></p><p>Logic可根据特性标签实现对消息源的订阅</p><p>三层结构对应的关系：<strong>n:1:n</strong></p><img src="/BVRP3.0_Turtorials/Watch%E7%BB%93%E6%9E%84/1-1.png" class=""><a id="more"></a><hr><h1 id="Watch基本结构"><a href="#Watch基本结构" class="headerlink" title="Watch基本结构"></a>Watch基本结构</h1><ul><li><strong>Entity</strong> </li></ul><p><strong>说明</strong>： 数据实体，继承自<strong>EObject</strong>,并实现了ISerializable接口，包含2个属性的初始化事件Id、Enable(实体被订阅时触发)。提供事件的发送方法。提供对自身数据的序列化（仅支持JsonDotNet可序列化的数据类型）</p><p><strong>应用示例</strong>：</p><p>字段的定义必须有属性包装，并按照如下方式编写</p><pre><code>public class HelloEntity：Entity{  //带有此标签，表示会发送初始化事件消息   [FireInitEvent]   private int _id = 0;   public int Id   {       get =&gt; _id; set       {           int oldValue = _id;           _id = value;           //发送属性变化事件，第一个参数的名字与属性名称保持一致           FireEvent(&quot;Id&quot;, oldValue, value);       }   }   private string _sex = &quot;男&quot;;   public string Sex   {       get =&gt; _sex;       set       {           string oldValue = _sex;           _sex = value;           //发送属性变化事件           FireEvent(&quot;Sex&quot;, oldValue, value);       }   }} </code></pre><p>方法定义及事件触发如下编写</p><pre><code>public void FindIndex(string name) {     //dosomething    //发送方法调用事件，第一个参数的名字与方法名保持一致    FireEvent(&quot;FindIndex&quot;, new object[] { name });}</code></pre><ul><li><strong>DataModelBehaviour</strong> </li></ul><p><strong>说明</strong>： 实体绑定（以GameObject为单位，首先必须关注自身的实体数据，其次也可以关注其他GameObject上的实体数据），事件分发，建立实体和逻辑之间的关联关系，需要挂载到unity的GameObject上。</p><p><strong>应用示例：</strong> 以下示例性代码主要说明，DataModel（即DataModelBehaviour）对实体数据的操作。</p><pre><code>//定义自己的DataModel，继承DataModelBehaviourpublic class HelloModel : DataModelBehaviour{    //重写Awake，自身实体的绑定（第一种），一般在Awake中完成，建议方式    protected override void Awake()    {        Entities.Add(new HelloEntity());        base.Awake();    }    //重写Start，    protected override void Start()    {        base.Start();        //自身实体的绑定（第二种）        this.AttachEntity(new HelloEntity());    }    //绑定其他DataModel上的Entity     public void AttachOtherEntity()     {          //查找对应的DataModel         var otherModel = FindObjectOfType&lt;BindOtherModel&gt;();         this.AttachEntity&lt;BingdingEntity&gt;(otherModel);     }    //实体属性的解绑(包括自身和其他)     public void DettachOtherOrMyEntity()     {        //解绑自身的Entity        this.DetachEntity&lt;HelloEntity&gt;(this);         //解绑已订阅的其他DataModel上的实体对象         var otherModel = FindObjectOfType&lt;BindOtherModel&gt;();         this.DetachEntity&lt;BingdingEntity&gt;(otherModel);     }}</code></pre><ul><li><p><strong>LogicBehaviour</strong> ：    处理由DataModelBehaviour转发而来的消息，负责处理具体的业务逻辑，需要挂载到unity的GameObject上</p><pre><code> //Interested标签代表感兴趣的实体对象，如果没有此标签，则默认对所有的Entity都感兴趣//[Interested]//[Interested(typeof(HelloEntity))]//[Interested(Types = new Type[] { typeof(Entity), typeof(Entity) })]public class HelloLogic : LogicBehaviour{        //编写具体的业务逻辑        public override void ProcessLogic(IEvent evt)        {            //属性初始化消息，判断必须在PropertyEvent前            if (evt is PropertyInitEvent)            {            }            else if(evt is PropertyEvent)            {            }            else if(evt is MethodEvent)            {            }        }    }}</code></pre></li><li><p><strong>具体图示</strong></p></li></ul><p><img src="2-1.jpg" alt="关系图"></p><hr><h1 id="Watch结构使用的注意事项"><a href="#Watch结构使用的注意事项" class="headerlink" title="Watch结构使用的注意事项"></a>Watch结构使用的注意事项</h1><ul><li><p><strong>在DataModelBehaviour中，提供了DataModelPool对象池引用，存放了当前场景中所有的DataModelBehaviour引用</strong></p></li><li><p><strong>在DataModelBehaviour中，提供了GameObjectPool对象池引用，存放了当前场景中所有的GameObject引用</strong></p></li><li><p><strong>在DataModelBehaviour中，当有物体销毁时，会自动处理有关的绑定事件</strong></p></li><li><p><strong>在DataModelBehaviour中，提供了对自身已关联实体对象的查找方法</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> BVRP3.0 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/BVRP3.0_Turtorials/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/BVRP3.0_Turtorials/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h1><p>如果一个类A 的功能实现需要借助于类B，那么就称类B是类A的依赖，如果在类A的内部去实例化类B，那么两者之间会出现较高的耦合，一旦类B出现了问题，类A也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难维护，并且很容易出现问题。要解决这个问题，就要把A类对B类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作<strong>控制反转</strong>（IOC Inversion Of Control）。控制反转是一种思想，是能够解决问题的一种可能的结果，而<strong>依赖注入</strong>（Dependency Injection）就是其最典型的实现方法。<strong>由第三方（我们称作IOC容器）来控制依赖，把他通过构造函数、属性或者工厂模式等方法，注入到类A内，这样就极大程度的对类A和类B进行了解耦</strong>。</p><a id="more"></a><hr><h1 id="BVRP中的IOC"><a href="#BVRP中的IOC" class="headerlink" title="BVRP中的IOC"></a>BVRP中的IOC</h1><p>IoC容器作为对象存储区持有对象引用，在存储区内的对象被称为托管对象，其他对象可以通过IoC容器获取托管对象的引用或通过IoC容器创建临时对象。托管对象一般由IoC容器维护其生命周期。</p><p><strong>BVRP中的IOC容器叫做InjectService</strong>，具备静态注册和瞬态注册两套对象托管方法，每套注册方法又分为实例注册、接口注册、函数注册。静态注册作用将托管对象作为单例使用，瞬态注册作用是在需要时临时创建对象。实例注册指将一个对象注册为托管对象，托管对象暴露所有公有属性、字段和函数。接口注册指将一个接口的类型和接口具体的实现注册为托管对象，托管对象仅暴露公有函数。函数注册指将一个对象的方法注册为托管“对象”，托管对象仅暴露一个特定函数</p><hr><h1 id="InjectService所支持的API函数"><a href="#InjectService所支持的API函数" class="headerlink" title="InjectService所支持的API函数"></a>InjectService所支持的API函数</h1><pre><code>//在容器中获取一个实例引用public static object Get(Type interfaceType);//在容器中获取一个实例引用public static TInterface Get&lt;TInterface&gt;() where TInterface : class;//想实例中注入对象； 此方法实现依赖与注解、反射、递归public static void InjectInto(object instance);//打印容器内容public static IEnumerable&lt;string&gt; Print();//注册一个单利服务，被注册的单利在软件的软件整个生命周期内都存且指存在唯一实例；public static void RegisterSingleton&lt;TInstance&gt;(TInstance instance) where TInstance : class;//注册一个单利服务，被注册的单利在软件的软件整个生命周期内都存且指存在唯一实例；public static void RegisterSingleton&lt;TInstance&gt;(Func&lt;TInstance&gt; factory) where TInstance : class;//注册一个单利服务，被注册的单利在软件的软件整个生命周期内都存且指存在唯一实例；public static void RegisterSingleton&lt;TInterface, TInstance&gt;(TInstance instance) where TInstance : class;//注册一个单利服务，被注册的单利在软件的软件整个生命周期内都存且指存在唯一实例；public static void RegisterSingleton&lt;TInstance&gt;() where TInstance : class, new();//注册一个单利服务，被注册的单利在软件的软件整个生命周期内都存且指存在唯一实例；public static void RegisterSingleton&lt;TInterface, TInstance&gt;() where TInstance : class, new();//注册一个单利服务，被注册的单利在软件的软件整个生命周期内都存且指存在唯一实例；public static void RegisterSingleton&lt;TInterface, TInstance&gt;(Func&lt;TInstance&gt; factory) where TInstance : class;//注册一个瞬态服务，在每次执行字段的Get时都会实例化一个新的服务实例public static void RegisterTransient&lt;TInstance&gt;(Func&lt;TInstance&gt; factory) where TInstance : class;//注册一个瞬态服务，在每次执行字段的Get时都会实例化一个新的服务实例public static void RegisterTransient&lt;TInterface, TInstance&gt;(Func&lt;TInstance&gt; factory) where TInstance : class;//注册一个瞬态服务，在每次执行字段的Get时都会实例化一个新的服务实例public static void RegisterTransient&lt;TInstance&gt;() where TInstance : class, new();//注册一个瞬态服务，在每次执行字段的Get时都会实例化一个新的服务实例public static void RegisterTransient&lt;TInterface, TInstance&gt;() where TInstance : class, new();// 删除注册的实例引用public static bool Unregister&lt;TInterface&gt;() where TInterface : class, new();//删除所有注册实例引用public static void UnregisterAll();</code></pre><hr><h1 id="InjectService的应用"><a href="#InjectService的应用" class="headerlink" title="InjectService的应用"></a>InjectService的应用</h1><h2 id="实例创建"><a href="#实例创建" class="headerlink" title="实例创建"></a>实例创建</h2><h3 id="单例服务"><a href="#单例服务" class="headerlink" title="单例服务"></a>单例服务</h3><p>单例服务指，实例在被创建后，在整个软件生命周期中只存在唯一一个实例。</p><ul><li><p>使用示例一（类注入）</p><pre><code>//简单类public class LogService{}//Mono类public class UIManager:MonoBehaviour{}//单例注入InjectService.RegisterSingleton(new LogService());InjectService.RegisterSingleton(GameObject.FindObjectOfType&lt;UIManager&gt;());</code></pre></li></ul><ul><li><p>使用示例二（接口注入）</p><pre><code>//日志接口public interface ILog{}//web端logpublic class WebLogService:ILog{}//通用logpublic class CommonLogService:ILog{}//单例注入 //if web平台InjectService.RegisterSingleton&lt;ILog,WebLogService&gt;(new WebLogService()); //if ios平台InjectService.RegisterSingleton&lt;ILog,CommonLogService&gt;(new CommonLogService());</code></pre></li></ul><ul><li><p>使用示例三（工厂注入）</p><pre><code>//继承自通用log，ios端logpublic class IosLogService:CommonLogService{}//工厂方法public TInstance FacMethod(){ //do something  return new IosLogService();}//单例注入InjectService.RegisterSingleton&lt;CommonLogService&gt;(FacMethod);InjectService.RegisterSingleton&lt;ILog,CommonLogService&gt;(FacMethod);</code></pre></li></ul><h3 id="瞬态服务"><a href="#瞬态服务" class="headerlink" title="瞬态服务"></a>瞬态服务</h3><p>瞬态服务指，每次都会创建一个新的实例返回给使用者，不是唯一的。</p><ul><li><p>使用示例一（类注入）</p><pre><code>//一般类public class SpawnCube(){     }//瞬态注入InjectService.RegisterTransient(new SpawnCube());</code></pre></li><li><p>使用示例二 （接口注入）</p><pre><code>public interface ISpawnShape{}public class SpawnBullet:ISpawnShape{}//瞬态注入InjectService.RegisterTransient&lt;ISpawnShape,SpawnBullet&gt;(new SpawnBullet());</code></pre></li><li><p>使用示例三 （工厂注入）</p><pre><code>public class SpawnAk_Bullet:SpawnBullet{}//工厂方法public TInstance FacMethod(){ //do something  return new SpawnBullet();}//瞬态注入InjectService.RegisterTransient&lt;SpawnBullet&gt;(FacMethod);InjectService.RegisterTransient&lt;ISpawnShape,SpawnBullet&gt;(FacMethod);</code></pre></li></ul><h2 id="实例获取"><a href="#实例获取" class="headerlink" title="实例获取"></a>实例获取</h2><p>在BVRP提供的IOC容器InjectService中，提供了两种实例获取的方式</p><h3 id="标签注入"><a href="#标签注入" class="headerlink" title="标签注入"></a>标签注入</h3><p>使用标签的方式，必须在当前类初始化的时候从容器中获取已经存在的实例，此种方式的优点在于，可以将所需要的全局实例注入到父类当中，在子类当中便已经默认存在这些全局实例</p><pre><code>//以Mono类为例public class GetInstance:Monobehaviour{ [Inject] private LogService _logService=null; [Inject] private ILog  _webLogService=null; void Start() {   //执行依赖注入操作，被标签标记的对象必须是已经初始化过的   InjectService.InjectInto(this); }}</code></pre><h3 id="直接获取"><a href="#直接获取" class="headerlink" title="直接获取"></a>直接获取</h3><p>通过InjectService提供的Get方法直接获取IOC容器中存在的实例，防止抛出异常，可先判断当前IOC中是否存在当前类型的实例</p><pre><code>//以Mono类为例public class GetInstance:Monobehaviour{ //类声明 private LogService _logService=null; //以接口声明 private ILog  _webLogService=null; void Start() {   //获取已经存在的实例    if (InjectService.Get&lt;_logService&gt;() != null)    {        _logService=InjectService.Get&lt;_logService&gt;();    }    if (InjectService.Get&lt;ILog&gt;() != null)    {        _logService=InjectService.Get&lt;ILog&gt;();    } }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> BVRP3.0 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有限状态机</title>
      <link href="/BVRP3.0_Turtorials/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/BVRP3.0_Turtorials/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是有限状态机"><a href="#什么是有限状态机" class="headerlink" title="什么是有限状态机"></a>什么是有限状态机</h1><p>有限状态机简称就是状态机，因为一般的状态机的状态都是离散和可举的，即为有限，所以后面的介绍都不加有限二字。状态机表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。所以状态机会包含以下几个重要的元素：</p><ul><li><p><strong>State</strong>：状态。一个标准的状态机最少包含两个状态：初始和终态。初态是状态机初始化后所处的状态，而终态顾名思义就是状态机结束时所处的状态。其他的状态都是一些流转中停留的状态。标准的状态机还会涉及到一些中间态，存在中间态的状态机流程就会比较复杂（用处也不是特别大，而且可以通过其他方式实现），所以在目标实现的状态机里不会引入这个概念。</p></li><li><p><strong>Event</strong>：事件。还有中描述叫Trigger，表达的意思都一样，就是要执行某个操作的触发器或口令：当状态机处于某个状态时，只有外界告诉状态机要干什么事情的时候，状态机才会去执行具体的行为，来完成外界想要它完成的操作。比如出去吃饭，说“点菜”，服务员才会拿着小本过来记录你要吃的菜，说的那句“点菜”，就相当于Event。</p></li><li><p><strong>Action</strong>：行为。状态变更索要执行的具体行为。还是拿上面点菜的例子，服务员拿小本记录你定的菜的过程就是Action</p></li><li><p><strong>Transition</strong>：变更。一个状态接收一个事件执行了某些行为到达了另外一个状态的过程就是一个Transition。定义Transition就是在定义状态机的运转流程。</p></li></ul><img src="/BVRP3.0_Turtorials/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/1-1.png" class=""><p>上图就是一个最简单的状态机，一个初态，一个流转状态，一个终态，初态到流状态是不需要任何操作的，State1当发生了Event1事件时，执行Action1到达了终态。（我们最终实现的状态机，会把初态和终态都当做一个流状态来对待）。</p><hr><a id="more"></a><h1 id="BVRP中的有限状态机"><a href="#BVRP中的有限状态机" class="headerlink" title="BVRP中的有限状态机"></a>BVRP中的有限状态机</h1><ul><li>StateMachine</li></ul><p>定义状态机</p><ul><li>StateMachineRunner</li></ul><p>继承自Unity的MonoBehaviour，用于初始化状态机，并更新状态等，自动添加。</p><h2 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h2><p>状态的定义采用枚举，定义类似如下c#代码</p><pre><code>public enum TcpState{    listen，    connect，    close        }</code></pre><h2 id="回调支持"><a href="#回调支持" class="headerlink" title="回调支持"></a>回调支持</h2><table><thead><tr><th>回调函数类型</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>Enter</td><td>void/IEnumator</td><td>状态进入，返回值可为两种类型</td></tr><tr><td>Exit</td><td>void/IEnumator</td><td>状态退出，返回值可为两种类型</td></tr><tr><td>Finally</td><td>void</td><td>状态退出调用</td></tr><tr><td>Update</td><td>void</td><td>处于当前状态时，循环调用，频率与MonoBehaviour中的Update一样</td></tr><tr><td>LateUpdate</td><td>void</td><td>处于当前状态时，循环调用，频率与MonoBehaviour中的LateUpdate一样</td></tr><tr><td>FixedUpdate</td><td>void</td><td>处于当前状态时，循环调用，频率与MonoBehaviour中的FixedUpdate一样</td></tr><tr><td>OnCollisionEnter</td><td>void</td><td>当有碰撞发生时调用</td></tr></tbody></table><h2 id="回调函数定义规则"><a href="#回调函数定义规则" class="headerlink" title="回调函数定义规则"></a>回调函数定义规则</h2><p>状态回调函数命名规则，枚举值为回调函数名的前缀，中间为下划线_，后缀为回调函数名。示例：EnumValue_Enter，如果以TcpState.listen状态为例，则可定义的回调函数名为</p><pre><code>listen_Enterlisten_Exitlisten_Finallylisten_Update---</code></pre><h2 id="状态机初始化"><a href="#状态机初始化" class="headerlink" title="状态机初始化"></a>状态机初始化</h2><ul><li><p>调用StateMachine的静态初始化方法,会自动挂载StateMachineRunner</p><pre>public static StateMachine<T> Initialize(MonoBehaviour component)public static StateMachine<T> Initialize(MonoBehaviour component, T startState)</pre></li><li><p>挂载StateMachineRunner，调用初始化方法</p></li></ul><pre>  //获取对象  StateMachineRunner= FindObjectOfType<StateMachineRunner>(); //调用初始化方法  public StateMachine<T> Initialize<T>(MonoBehaviour component)   public StateMachine<T> Initialize<T>(MonoBehaviour component, T startState) </pre><h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><pre>使用StateMachine实例，调用对应的切换函数//切换状态public void ChangeState(T newState)//切换状态，可选的StateTransition有两种，Safe表示等待上一个携程结束，Overwrite直接切换public void ChangeState(T newState, StateTransition transition)</pre>]]></content>
      
      
      <categories>
          
          <category> BVRP3.0 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础内容</title>
      <link href="/BVRP3.0_Turtorials/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
      <url>/BVRP3.0_Turtorials/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容概要"><a href="#一、内容概要" class="headerlink" title="一、内容概要"></a>一、内容概要</h1><p>BVRP3.0核心模块中一共包含3个基础内容：</p><ul><li>Events：事件驱动系统</li><li>Execption：异常类</li><li>Serialize：序列化接口</li></ul><p>文件结构如下图所示：</p><img src="/BVRP3.0_Turtorials/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/1-1.jpg" class=""><hr><a id="more"></a><h1 id="二、事件系统（Events）"><a href="#二、事件系统（Events）" class="headerlink" title="二、事件系统（Events）"></a>二、事件系统（Events）</h1><h2 id="接口描述"><a href="#接口描述" class="headerlink" title="接口描述"></a>接口描述</h2><p>事件系统包含以下几个重要接口</p><ul><li><strong>IEvent</strong></li></ul><p>约束事件消息体必须实现的接口</p><pre><code>public interface IEvent{/// &lt;summary&gt;/// 发送事件的对象/// &lt;/summary&gt;object EventSource { set; get; }/// &lt;summary&gt;/// 一般是一个属性或方法的名称/// &lt;/summary&gt;string EventName { set; get; }}</code></pre><ul><li><strong>IEventSource</strong></li></ul><p>约束事件消息源应有的上下文</p><pre><code>public interface IEventSource{/// &lt;summary&gt;/// 事件监听器个数/// &lt;/summary&gt;int Count { get; }/// &lt;summary&gt;/// 清除事件侦听器列表/// &lt;/summary&gt;void ClearListeners();/// &lt;summary&gt;/// 判断是否已经拥有事件源/// &lt;/summary&gt;/// &lt;param name=&quot;listener&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;bool Contains(IEventListener listener);/// &lt;summary&gt;/// 添加事件侦听器/// &lt;/summary&gt;/// &lt;param name=&quot;listener&quot;&gt;&lt;/param&gt;void AddEventListener(IEventListener listener);/// &lt;summary&gt;/// 删除事件侦听器/// &lt;/summary&gt;/// &lt;param name=&quot;listener&quot;&gt;&lt;/param&gt;void RemoveEventListener(IEventListener listener);/// &lt;summary&gt;/// 广播事件/// &lt;/summary&gt;/// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;void FireEvent(IEvent evt);/// &lt;summary&gt;/// 关闭事件广播/// &lt;/summary&gt;void OffFire();/// &lt;summary&gt;/// 开启事件广播/// &lt;/summary&gt;void OnFire();}</code></pre><ul><li><strong>IEventSupportable</strong></li></ul><p>定义一个持有事件源引用的对象的行为操作</p><pre><code>public interface IEventSource{/// &lt;summary&gt;/// 事件监听器个数/// &lt;/summary&gt;int Count { get; }/// &lt;summary&gt;/// 清除事件侦听器列表/// &lt;/summary&gt;void ClearListeners();/// &lt;summary&gt;/// 判断是否已经拥有事件源/// &lt;/summary&gt;/// &lt;param name=&quot;listener&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;bool Contains(IEventListener listener);/// &lt;summary&gt;/// 添加事件侦听器/// &lt;/summary&gt;/// &lt;param name=&quot;listener&quot;&gt;&lt;/param&gt;void AddEventListener(IEventListener listener);/// &lt;summary&gt;/// 删除事件侦听器/// &lt;/summary&gt;/// &lt;param name=&quot;listener&quot;&gt;&lt;/param&gt;void RemoveEventListener(IEventListener listener);/// &lt;summary&gt;/// 广播事件/// &lt;/summary&gt;/// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;void FireEvent(IEvent evt);/// &lt;summary&gt;/// 关闭事件广播/// &lt;/summary&gt;void OffFire();/// &lt;summary&gt;/// 开启事件广播/// &lt;/summary&gt;void OnFire();}</code></pre><ul><li><strong>IEventListener</strong></li></ul><p>定义事件侦听器的处理函数</p><pre><code>public interface IEventListener{/// &lt;summary&gt;/// 当发生新事件时触发此函数/// &lt;/summary&gt;/// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;void OnEvent(IEvent evt);}</code></pre><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><ul><li><p><strong>事件消息体</strong></p><p>在事件系统中对消息体（IEvent）的实现做了三层处理，属性初始化事件消息体（需要添加特定的特性标签触发），对应的继承关系如下图：</p></li></ul><p><img src="2-1.png" alt="消息体的实现以及继承关系"></p><ul><li><strong>事件消息源</strong></li></ul><p>EventSource实现了IEventSource接口<br>管理事件侦听器<br>向事件侦听器发送属性事件或者方法事件</p><p><img src="2-2.png" alt="事件消息源"></p><ul><li><strong>包含事件消息源引用的根对象</strong></li></ul><p>在事件系统中，对IEventSupprottable接口实现，名为EObject（非Mono类）。EObject持有事件消息源（EventSource）的引用，并封装了对EventSource的操作。是默认的事件对象基类。在为EObject绑定侦听器（IEventListener）时，会默认触发一个名为Enable的属性事件，默认值为True</p><p><img src="2-3.png" alt="事件源封装"></p><ul><li><strong>事件侦听器</strong></li></ul><p>此接口提供了一个接收实现了IEvent接口的对象参数， 事件消息对象中的属性变化和方法调用都会分发到OnEvent方法中。使用这需要根据evt参数区别出具体的消息体，在处理相应的业务逻辑</p><p><img src="2-4.png" alt=""></p><ul><li><p><strong>事件系统流程描述</strong></p><p>  1、先创建事件消息对象（EObject、EObject的派生类或者自己实现了IEventSupportable接口的类）</p><p>  2、为事件消息对象添加实现了IEventListener接口的侦听器</p><p>  3、执行属性变化或者方法调用，组装消息体。并触发事件。（与BVRP2.0的不同在于，在BVRP3.0中，事件的触发，一般都需要手动封装在属性的set方法之中或者方法的调用之后）</p><p>  4、侦听器接收到事件，根据事件类型的不同具体处理业务逻辑</p></li><li><p><strong>基本的结构图</strong></p></li></ul><p><img src="2-5.png" alt=""></p><hr><h1 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h1><p>异常消息有两种格式：</p><ul><li>为一般格式的英文字符串，描述了抛出异常的可能原因。</li><li>【类名：方法名：可能原因】。</li></ul><hr><h1 id="四、序列化"><a href="#四、序列化" class="headerlink" title="四、序列化"></a>四、序列化</h1><p>ISerializabel接口具有如图汇总所示的5个常用接口，在BVRP3.0中对数据的序列化都是json格式，并且以JsonDotNet插件作为工具。在此模块中，已经实现了ISerializabel接口的类都包含AbstractEvent、MethodEvent、PropertyEvent、PropertyInitEvent、EObject。</p><p><img src="4-1.png" alt="序列化接口"></p><hr><h1 id="五、在BVRP3-0中的作用"><a href="#五、在BVRP3-0中的作用" class="headerlink" title="五、在BVRP3.0中的作用"></a>五、在BVRP3.0中的作用</h1><p>提供事件驱动基础，提供对三层结构的支持，提供对存储模块的支持。</p><h1 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h1><ul><li><strong>编写事件触发时，事件名称必须与对应的属性名称和方法名称保持一致</strong></li><li><strong>处理侦听器中收到的事件时，需要注意先后顺序，PropertyInitEvent必须在PropertyEvent之前</strong></li><li><strong>如果需要序列化事件消息对象（即数据实体），需要继承ISerializable接口，并实现相关内容</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> BVRP3.0 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
